{"name":"Perl y Geometría","tagline":"","body":"# Perl, vectores, geometría, problemas, algoritmos y arte y todo lo demás\r\n\r\nSalvador Fandiño (sfandino@yahoo.com)\r\n\r\nGranada Perl Workshop - Junio 2014\r\n\r\n---\r\n\r\n# Vector\r\n\r\nAn Euclidean vector is a geometric quantity having **magnitude** and **direction** expressed numerically as tuples **`[x0, x1, x2, ...]`**.\r\n\r\n---\r\n\r\n## ... en geometría\r\n\r\n- Un punto en el espacio\r\n\r\n- Una dirección\r\n\r\n- La separación entre dos puntos\r\n\r\n- Un eje de giro\r\n\r\n- Una rotación\r\n\r\n- ...\r\n\r\n---\r\n\r\n## ... en matemáticas\r\n\r\n**(espacio vectorial)**\r\n\r\n- Suma y resta, vector nulo (`[0, 0, 0, ...]`)\r\n\r\n- Multiplicación por un escalar\r\n\r\n- Producto escalar\r\n\r\n- En 3 dimensiones, producto vectorial\r\n\r\n- Equivalencia con matrices 1xN (v. col.) o Nx1 (v. fila)\r\n\r\n---\r\n\r\n## ... en Perl\r\n\r\n- Vector::Object3D (3D)\r\n- Math::VectorReal (3D)\r\n- Math::Vec (3D)\r\n- Math::GSL::Vector\r\n- y ...\r\n\r\n---\r\n\r\n## ... Los buenos!\r\n\r\n- PDL\r\n- Math::Vector::Real\r\n\r\n---\r\n\r\n## PDL\r\n\r\n- \"Perl Data Language\"\r\n\r\n- Procesado de datos multidimensionales\r\n\r\n- Muy eficiente (CPU y memoria)\r\n\r\n- Inspirado en APL\r\n\r\n---\r\n\r\n> ## APL\r\n    \r\n> - \"A Programming Language\"\r\n\r\n> - 196x\r\n\r\n> - datos multidimensionales\r\n\r\n> - estructuras de control implicitas\r\n\r\n> <img src=\"images/apl-keyboard.png\">\r\n\r\n---\r\n\r\n> ## APL, ejemplos\r\n\r\n> Números primos entre 1 y R:\r\n\r\n> `(~R∊R∘.×R)/R←1↓ιR`\r\n\r\n> Conway's Game of Life\r\n\r\n> `life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}`\r\n\r\n---\r\n\r\n> ## [J](http://en.wikipedia.org/wiki/J_%28programming_language%29)\r\n\r\n> Variante moderna de APL\r\n\r\n> Open Source\r\n\r\n> ASCII\r\n\r\n> Inspiración de los [adverbios](http://perl6advent.wordpress.com/2013/12/10/day-10-adverbly-adverby-adverbs/) de Perl 6\r\n\r\n---\r\n\r\n## PDL, inconvenientes\r\n\r\n- Curva de aprendizaje\r\n\r\n- Soporta matrices, no vectores\r\n\r\n- No intuitivo\r\n\r\n- Es XS\r\n\r\n---\r\n\r\n## Math::Vector::Real\r\n\r\n- Aritmética con vectores n-dimensionales en el dominio de los números reales\r\n\r\n- Fácil de usar e intuitivo\r\n\r\n- Escrito en Perl puro\r\n\r\n- Velocidad, objetivo secundario...\r\n\r\n---\r\n\r\n## Math::Vector::Real::XS\r\n\r\n- M::V::R reimplementado en XS\r\n\r\n- Más rápido x5 ~ x10\r\n\r\n- Se carga automáticamente si esta instalado\r\n\r\n        use Math::Vector::Real;\r\n\r\n- C API...\r\n\r\n---\r\n\r\n> ## C API\r\n\r\n> Problema: Tengo un módulo en XS (`M::S`) y quiero que otro módulo (`M::C`) tambien escrito en XS pueda utilizarlo\r\n\r\n---\r\n\r\n> ## C API\r\n\r\n> - ¿Donde esta el problema?\r\n\r\n>   `M::C` puede usar [`eval_pv`](https://metacpan.org/pod/distribution/perl/pod/perlcall.pod).\r\n\r\n> - Guardo en un hash (`%M::S::c_api`), punteros a las funciones C que quiero exportar. Desde `M::C`, recupero los punteros y los uso.\r\n\r\n>   Ejemplo: [Time::HiRes](https://metacpan.org/pod/Time::HiRes#C-API).\r\n\r\n> - o...\r\n\r\n---\r\n\r\n> ## Module::CAPIMaker\r\n\r\n> A partir de la declaración de las funciones que queremos exportar:\r\n\r\n>        int foo(double)\r\n>        char *bar(void)\r\n\r\n> Genera todo lo necesario para que las mismas se puedan utilizar transparentemente desde código XS en otros módulos.\r\n\r\n---\r\n\r\n> ## Module::CAPIMaker\r\n\r\n> Lo usa\r\n\r\n> - Math::Int64\r\n\r\n> - Math::Int128\r\n\r\n> No lo usa\r\n\r\n> - Math::Vector::Real::XS\r\n\r\n---\r\n\r\n## Math::Vector::Real\r\n\r\n    $u = V(1.7, 2.0); $v = V(-1, 3.2)\r\n\r\n    $w = 7 * $u - $v + [0, 0.1];\r\n    $s = $u * $w; # producto scalar\r\n    $z = $u x $w; # producto vectorial\r\n\r\n    $n = abs($u); # norma\r\n\r\n    $v1 = $v->versor;\r\n\r\n\r\n---\r\n\r\n> ## El operador \"x\"\r\n\r\n> Bug [#121827](https://rt.perl.org/Public/Bug/Display.html?id=121827) for perl5: overloading 'x' is broken\r\n\r\n>        scalar((...) x $a)\r\n\r\n---\r\n\r\n## La familia <font size=\"-1\">Math::Vector::</font>Real\r\n\r\n- Math::Vector::Real\r\n- Math::Vector::Real::XS\r\n- Math::Vector::Real::Random\r\n- Math::Vector::Real::kdTree\r\n- Math::Vector::Real::Farthest\r\n- Math::Vector::Real::MultiNormalMixture\r\n- ... y los ile[git](https://github.com/salva?tab=repositories)imos!\r\n\r\n---\r\n\r\n## Math::Vector::Real::Random\r\n\r\n- Generación de vectores aleatorios\r\n\r\n   - versores\r\n\r\n   - caja\r\n\r\n   - hiperesfera\r\n\r\n   - paralelotopo\r\n\r\n   - normal multivariante\r\n\r\n- Basado en Math::Random\r\n\r\n---\r\n\r\n## Math::Vector::Real::kdTree\r\n\r\n- k-d tree\r\n\r\n  <img src=\"images/k-d_tree.png\" align=\"right\">\r\n\r\n  - estructura simple y muy versatil\r\n\r\n  - busquedas n-dimensionales eficientes\r\n\r\n      - `find_in_ball`\r\n\r\n      - `find_in_box`\r\n\r\n      - `nearest_vector`\r\n\r\n      - `farthest_vector`\r\n\r\n  - otros algoritmos\r\n\r\n       - k-means\r\n\r\n- módulo \"cerrado\"\r\n\r\n---\r\n\r\n## Math::Vector::Real\r\n\r\nMetodología de desarrollo: PDD\r\n\r\n---\r\n\r\n> ## PDD\r\n\r\n> ### Pique\r\n\r\n> ### Driven\r\n\r\n> ### Development\r\n\r\n---\r\n\r\n> ## PDD\r\n\r\n> Alguien me pregunta por correo o en un foro como hacer algo y...\r\n\r\n> - a mi se me ocurre un metodo pero tengo que probarlo\r\n\r\n> - o se como hacerlo, lo explico, nadie lo entiende\r\n\r\n> - o con uno de mis módulos casi se puede resolver\r\n\r\n> Entonces, ¡me pico y lo hago!\r\n\r\n---\r\n\r\n> ## PDD, ejemplo:\r\n\r\n> - 17 abril, Mr D.R.\r\n\r\n>  > Is there any chance you have a method to calculate the largest distance between two vectors in a set?\r\n\r\n> - 25 abril: `Math::Vector::Real::Farthest` en CPAN\r\n\r\n> - 20 mayo, Mr D.R. otra vez:\r\n\r\n>  > I hate to request [...] but I found an article describing an implementation of k-Means [...]\r\n\r\n> - 1 junio: nueva version de `Math::Vector::Real::kdTree` con soporte para k-means clustering.\r\n\r\n---\r\n\r\n# Problemas\r\n\r\n---\r\n\r\n## Generación de clusters\r\n\r\nProblema: Para validar un algoritmo, necesito generar un conjunto de\r\npuntos n-dimensionales que formen clusters \"naturales\".\r\n\r\n---\r\n\r\n### Solución 1: Metodo constructivista\r\n\r\n1. De manera ingeniosa me invento una función parametrizable\r\n(u objeto) que sea capaz de generar \"clusters\".\r\n\r\n2. Combino varios de estos clusters mediante una parametrización aleatoria.\r\n\r\nEjemplo:\r\n\r\n    my @sphere = map {\r\n            my $center = Math::Vector::Real->random_in_box(3, 1.0);\r\n            my $radius = rand(0.5);\r\n            Sphere->new($center, $radius)\r\n        } 1..$M;\r\n\r\n    my @v = map { $sphere[rand($M)]->random_point } 1..$size;\r\n\r\n---\r\n\r\n### Solución 1: Método constructivista\r\n\r\nLimitaciones:\r\n\r\n- Los datos generados siguen un patrón\r\n\r\n- Los clusters generados no cumplen la condición de \"naturales\"\r\n\r\n---\r\n\r\n<img src=\"images/density-function.png\" align=\"right\">\r\n\r\n### Solución 2: Metodo probabilístico:\r\n\r\n1. Elijo una función de densidad de probabilidad\r\nn-dimensional `f($v)`\r\n\r\n2. Utilizo esa función para generar puntos aleatorios\r\n\r\nEjemplo ([Rejection sampling](http://en.wikipedia.org/wiki/Rejection_sampling)):\r\n\r\n        while (@p < $size) {\r\n            my $v = Math::Vector::Real->random_in_box($dim, 1);\r\n            if (rand($max_f) < f($v)) {\r\n                push @p, $v;\r\n            }\r\n        }\r\n\r\n---\r\n\r\n### Solución 2: Método probabilístico\r\n\r\nLimitaciones:\r\n\r\n- La probabilidad de descarte puede ser muy alta (*)\r\n\r\n- No deja de ser una variante del metodo constructivista\r\n\r\n---\r\n\r\n### Solución 3: Método \"inspirado\"\r\n\r\n1. Creo una funcion de densidad de probabilidad a partir de otros datos de origen externo\r\n\r\n2. Utilizo esa función para generar puntos aleatorios\r\n\r\n---\r\n\r\n### Solución 3: Método \"inspirado\"\r\n\r\nEjemplo:\r\n\r\n1. Busco una imagen en Google\r\n2. La utilizo para generar una función de distribución bidimensional\r\n3. Genero puntos según esa distribución\r\n\r\n<img src=\"images/gato.png\">\r\n\r\n---\r\n\r\n[image2rand.pl](https://github.com/salva/p5-Tie-Array-Packed/blob/master/sample/image2rand.pl)\r\n\r\n    tie my(@acu), 'Tie::Array::Packed::DoubleNative';\r\n\r\n    for my $j (0..$height-1) {\r\n        for my $i (0..$width-1) {\r\n            my @c = $img->GetPixel(x => $i, y => $j);\r\n            my $c = ($c[2]*$c[2]+$c[1]*$c[1]+$c[0]*$c[0]) ** $exp;\r\n            push @acu, $acu[-1] + $c;\r\n        }\r\n    }\r\n\r\n    my $top = $acu[-1];\r\n    my $ref = tied(@acu);\r\n    for my $r (random_uniform($n, 0, $top)) {\r\n        my $ix = $ref->bsearch_le($r);\r\n        my $j = int($ix / $width);\r\n        my $i = $ix - $j * $width;\r\n        $out->SetPixel(x => $i, y => $j, color => [1, 1, 1]);\r\n    }\r\n\r\n---\r\n\r\n### Solución 3: Método \"inspirado\"\r\n\r\nLimitaciones:\r\n\r\n- Dificultad de obtener datos externos\r\n- Calidad de los datos externos\r\n- Escala mal (dimensión, resolución)\r\n\r\n---\r\n\r\n> ## Tie::Array::Packed\r\n\r\n> - Arrays densos en Perl\r\n\r\n> - Reduce el consumo de memoria un orden de magnitud\r\n\r\n> - Implementado en XS (pero la interfaz `tie` es lenta)\r\n\r\n> - Algunos métodos interesantes (ordenación, busqueda binaria, etc.)\r\n\r\n> <img src=\"images/illguts-av.png\"> Vs <img src=\"images/illguts-svpv.png\">\r\n\r\n\r\n\r\n\r\n---\r\n\r\n## Generación de clusters\r\n\r\n¿Más?\r\n\r\n---\r\n\r\n<img src=\"images/termite_hill.jpg\" align=\"right\">\r\n\r\n### Solución 4: Método emergente\r\n\r\n- Pasar horas y horas creando una arquitectura de agentes cuyo comportamiento emergente genere clusters\r\n\r\n- AI::Termites\r\n\r\n---\r\n\r\n`mplayer 'mf://images/termites/*.png' -mf fps=10 -fs`\r\n\r\n---\r\n\r\n### Solución 4: Método emergente\r\n\r\nLimitaciones\r\n\r\n- Lento\r\n\r\n- Podría haber un patrón oculto\r\n\r\n---\r\n\r\n## Generación de clusters\r\n\r\nPDD:\r\n\r\n- [3D test data that exhibits clustering?](http://perlmonks.org/?node_id=908684)\r\n\r\n- [Randomly biased, random numbers](http://perlmonks.org/?node_id=1065851)\r\n\r\n---\r\n\r\n<img src=\"images/cover.png\" align=\"right\">\r\n\r\n## Recubrimiento\r\n\r\nProblema: dado un conjunto de puntos N-dimensionales `A` y un\r\nparametro radio `$r`, encontrar un subconjunto mínimo del mismo `R`\r\ntal que para cualquier punto de `A` exista un punto en `R` a una\r\ndistancia menor que `$r`.\r\n\r\n---\r\n\r\n### Solución 1: Fuerza bruta\r\n\r\n- Garantiza solución globalmente óptima\r\n\r\n- Complejidad exponencial (probablemente NP-hard)\r\n\r\n- En la práctica no es viable\r\n\r\n---\r\n\r\n### Solución 2: Método del máximo gradiente\r\n\r\nRepetidamente elegimos el punto cuya bola cubra más elementos:\r\n\r\n    use Sort::Key::Top qw(ikeytail);\r\n    my @R;\r\n    while (@A) {\r\n      my $best = ikeytail { count_in_ball($_, $r, \\@A) } @A;\r\n      push @R, $best;\r\n      @A = grep { $best->dist($_) > $r } @A;\r\n    }\r\n\r\n---\r\n\r\n### Solución 2: Método del máximo gradiente\r\n\r\n- Simple y rápido\r\n\r\n- La solución suele ser buena, aunque no siempre\r\n\r\n---\r\n\r\n> ## Sort::Key::Top\r\n\r\n> - Selecciona el top-X de una lista\r\n\r\n>         @a = keytop { key($_) } $X => @data;\r\n\r\n>         # @a = (sort { key($a) cmp key($b) } @data)[0..$X-1]\r\n\r\n> - [Algoritmo de selección](http://en.wikipedia.org/wiki/Selection_algorithm)\r\n\r\n> - XS, muy rápido\r\n\r\n> - Multiples variantes (¡demasiadas!)\r\n\r\n---\r\n\r\n### Solución 3: Algoritmo genético\r\n\r\n- Seleccionamos un conjunto de soluciones diversas y no optimas\r\n\r\n- Las cruzamos y mutamos\r\n\r\n- Jugamos a la ruleta (cargada) con ellas\r\n\r\n- Repetimos\r\n\r\n---\r\n\r\n### Algorithm::GAUL\r\n\r\n- wrapper GAUL: [The Genetic Algorithm Utility Library](http://gaul.sourceforge.net/)\r\n\r\n    <img src=\"images/gaul_logo.jpeg\" align=\"right\">\r\n\r\n    - C\r\n    - rapida\r\n    - flexible\r\n    - parallela (hilos, MPI, ...)\r\n    - abandonada (2009)\r\n\r\n- [en progreso](https://github.com/salva/p5-AI-GAUL)... por siempre\r\n\r\n---\r\n\r\n    my $gaul = Algorithm::GAUL->new(len_chromo => scalar(@p),\r\n                                    population_size => $pop_size,\r\n                                    select_two => 'random',\r\n                                    select_one => 'aggresive',\r\n                                    mutation_ratio => 0.20,\r\n                                    seed => \\&seed,\r\n                                    evaluate => \\&weight,\r\n                                    adapt => \\&repair,\r\n                                    stop => \\&stop,\r\n                                    mutate => \\&mutate,\r\n                                    elitism => 'parents_survive',\r\n                                    scheme => 'lamarck_children',\r\n                                    crossover => \\&crossover);\r\n     while (...) {\r\n         $gaul->evolution(1);\r\n         my $s = $gaul->entity_by_rank(0)->[0];\r\n         ...\r\n     }\r\n\r\n---\r\n\r\n    sub crossover {\r\n        # say \"crossing...\";\r\n        my $s = \\$_[3][0];\r\n        my $d = \\$_[4][0];\r\n        my $p = $_[1][0];\r\n        my $m = $_[2][0];\r\n\r\n        my $z = $b0 + $db->random_in_box;\r\n        my $d2 = rand($diam);\r\n        $d2 *= $d2;\r\n        for my $ix (0..$#p) {\r\n            if ($z->dist2($p[$ix]) < $d2) {\r\n                vec($$s, $ix, 1) = vec($p, $ix, 1);\r\n                vec($$d, $ix, 1) = vec($m, $ix, 1);\r\n            }\r\n            else {\r\n                vec($$s, $ix, 1) = vec($m, $ix, 1);\r\n                vec($$d, $ix, 1) = vec($p, $ix, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n---\r\n\r\n    sub repair {\r\n        # say \"repairing chromosomes\";\r\n        for my $s (@{$_[1]}) {\r\n            my $m = $missing;\r\n            my $ix = -1;\r\n            while (defined($ix = bu_first($s, $ix + 1))) {\r\n                vec($m, $_, 1) = 0 for @{$cover[$ix]};\r\n            }\r\n            $ix = -1;\r\n            while (defined($ix = bu_first($m, $ix + 1))) {\r\n                my $r = $cover[$ix][rand scalar @{$cover[$ix]}];\r\n                vec($s, $r, 1) = 1;\r\n                vec($m, $_, 1) = 0 for @{$cover[$r]};\r\n            }\r\n        }\r\n    }\r\n\r\n---\r\n\r\n`mplayer 'mf://images/cover/*.png' -mf fps=10 -fs`\r\n\r\n---\r\n\r\n## Solución 3: Algoritmo genético\r\n\r\n- Dificil saber que esta pasando\r\n\r\n    - visualización\r\n\r\n    - ajuste del algoritmo\r\n\r\n- Dificil mutar y cruzar conservando calidad de la solución\r\n\r\n---\r\n\r\n> # Bit::Util\r\n\r\n> - Funciones para manipular un vector de bits\r\n\r\n>     - busqueda (`bu_first`, `bu_last`)\r\n\r\n>     - conteo (`bu_count`)\r\n\r\n> - en progreso (2012)\r\n\r\n> - XS\r\n\r\n> - pero código C sin optimizar\r\n\r\n---\r\n\r\n<img src=\"images/escher-circle-limit.jpg\" align=\"right\">\r\n\r\n## Cubrimiento aleatorio del plano\r\n\r\nPloblema: A partir de una figura geometrica básica (triangulo,\r\ncuadrado, circulo, etc.), llenar el plano posicionando la misma de\r\nmanera repetida y aleatoria.\r\n\r\n---\r\n\r\n<img src=\"images/filling-holes.png\" align=\"right\" width=\"50%\">\r\n\r\n## Cubrimiento aleatorio del plano\r\n\r\n- Subproblemas\r\n\r\n    - ¿Como buscar un agujero sin llenar?\r\n\r\n    - ¿Que cabe en el agujero?\r\n\r\n---\r\n\r\n## Math::Geometry::RandomPlaneFiller\r\n\r\n- Usa una estructura de k-d tree para particionar el plano (2D)\r\n\r\n- Para buscar agujeros\r\n\r\n    - Cada region tiene una probabilidad asignada proporcional al área aun libre\r\n\r\n    - Cuando se añade una figura nueva se reajustan las probabilidades\r\n\r\n- Para medir agujeros (rater)\r\n\r\n    - Enumera las figuras existentes ordenadas en base a una metrica parametrizable\r\n\r\n- [En progreso](https://github.com/salva/p5-Math-Geometry-RandomPlaneFiller)\r\n\r\n    - Solo implementado el soporte para circulos\r\n\r\n---\r\n\r\n`mplayer 'mf://images/random-plane-filler/*.png' -mf fps=10 -fs`\r\n\r\n\r\n---\r\n\r\n# FIN","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}